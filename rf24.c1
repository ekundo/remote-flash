#include <rf24.h>
#include <stdio.h>
#include <string.h>
#include <millis.c>

#define LOW 0
#define HIGH 1

static const char _rf24_datarate_e_str_0[] = "1MBPS";
static const char _rf24_datarate_e_str_1[] = "2MBPS";
static const char _rf24_datarate_e_str_2[] = "250KBPS";
static const char * const _rf24_datarate_e_str_P[] = {
  _rf24_datarate_e_str_0,
  _rf24_datarate_e_str_1,
  _rf24_datarate_e_str_2,
};
static const char _rf24_model_e_str_0[] = "nRF24LE1";
static const char * const _rf24_model_e_str_P[] = {
  _rf24_model_e_str_0,
};
static const char _rf24_crclength_e_str_0[] = "Disabled";
static const char _rf24_crclength_e_str_1[] = "8 bits";
static const char _rf24_crclength_e_str_2[] = "16 bits" ;
static const char * const _rf24_crclength_e_str_P[] = {
  _rf24_crclength_e_str_0,
  _rf24_crclength_e_str_1,
  _rf24_crclength_e_str_2,
};
static const char _rf24_pa_dbm_e_str_0[] = "PA_MIN";
static const char _rf24_pa_dbm_e_str_1[] = "PA_LOW";
static const char _rf24_pa_dbm_e_str_2[] = "PA_HIGH";
static const char _rf24_pa_dbm_e_str_3[] = "PA_MAX";
static const char * const _rf24_pa_dbm_e_str_P[] = { 
  _rf24_pa_dbm_e_str_0,
  _rf24_pa_dbm_e_str_1,
  _rf24_pa_dbm_e_str_2,
  _rf24_pa_dbm_e_str_3,
};

static const uint8_t _rf24_child_pipe[] =
{
  RF_RX_ADDR_P0, RF_RX_ADDR_P1, RF_RX_ADDR_P2, RF_RX_ADDR_P3, RF_RX_ADDR_P4, RF_RX_ADDR_P5
};
static const uint8_t _rf24_child_payload_size[] =
{
  RF_RX_PW_P0, RF_RX_PW_P1, RF_RX_PW_P2, RF_RX_PW_P3, RF_RX_PW_P4, RF_RX_PW_P5
};
static const uint8_t _rf24_child_pipe_enable[] =
{
  RF_EN_RXADDR_ERX_P0, RF_EN_RXADDR_ERX_P1, RF_EN_RXADDR_ERX_P2, RF_EN_RXADDR_ERX_P3, RF_EN_RXADDR_ERX_P4, RF_EN_RXADDR_ERX_P5
};

void _rf24_csn(int mode)
{
  if (mode == LOW)
  {
    sbit_clear(RFCON_SB_RFCSN);
  } else
  {
    sbit_set(RFCON_SB_RFCSN);
  }
}

void _rf24_ce(int level)
{
  if (level == LOW)
  {
    sbit_clear(RFCON_SB_RFCE);
  } else
  {
    sbit_set(RFCON_SB_RFCE);
  }
}

uint8_t _rf24_spi_send_read_byte(uint8_t byte)
{
  SPIRDAT = byte; //Send byte over SPI

  while(!(SPIRSTAT & SPIRSTAT_IRQ_RX_FIFO_READY)); //Wait for the transaction to finish

  IRCON_SB_RFRDY = BIT_FALSE; //Clear the IRQ bit

  return SPIRDAT; //Return the received value
}

uint8_t _rf24_read_register(uint8_t reg, uint8_t* buf, uint8_t len)
{
  uint8_t status;

  _rf24_csn(LOW);
  status = _rf24_spi_send_read_byte(RF_R_REGISTER | (RF_R_REGISTER_DATA & reg));
  while ( len-- )
    *buf++ = _rf24_spi_send_read_byte(0xff);
  _rf24_csn(HIGH);

  return status;
}

uint8_t _rf24_read_register_1_byte(uint8_t reg)
{
  uint8_t status;

  _rf24_csn(LOW);
  _rf24_spi_send_read_byte(RF_R_REGISTER | (RF_R_REGISTER_DATA & reg));
  status = _rf24_spi_send_read_byte(0xff);
  _rf24_csn(HIGH);

  return status;
}

uint8_t _rf24_write_register(uint8_t reg, const uint8_t* buf, uint8_t len)
{
  uint8_t status;

  _rf24_csn(LOW);
  status = _rf24_spi_send_read_byte(RF_W_REGISTER | (RF_W_REGISTER_DATA & reg));
  while ( len-- )
    _rf24_spi_send_read_byte(*buf++);
  _rf24_csn(HIGH);

  return status;}

uint8_t _rf24_write_register_1_byte(uint8_t reg, uint8_t value)
{
  uint8_t status;

  _rf24_csn(LOW);
  status = _rf24_spi_send_read_byte(RF_W_REGISTER | (RF_W_REGISTER_DATA & reg));
  _rf24_spi_send_read_byte(value);
  _rf24_csn(HIGH);

  return status;  
}

uint8_t _rf24_write_payload(const void* buf, uint8_t len)
{
  uint8_t status;
  const uint8_t* current = (const uint8_t*) buf;

  uint8_t data_len = len < _rf24_payload_size ? len : _rf24_payload_size;
  uint8_t blank_len = _rf24_dynamic_payloads_enabled ? 0 : _rf24_payload_size - data_len;

  _rf24_csn(LOW);
  status = _rf24_spi_send_read_byte(RF_W_TX_PAYLOAD);
  while ( data_len-- )
    _rf24_spi_send_read_byte(*current++);
  while ( blank_len-- )
    _rf24_spi_send_read_byte(0);
  _rf24_csn(HIGH);

  return status;
}

uint8_t _rf24_read_payload(void* buf, uint8_t len)
{
  uint8_t status;
  uint8_t* current = (uint8_t*) buf;

  uint8_t data_len = len < _rf24_payload_size ? len : _rf24_payload_size;
  uint8_t blank_len = _rf24_dynamic_payloads_enabled ? 0 : _rf24_payload_size - data_len;
  
  _rf24_csn(LOW);
  status = _rf24_spi_send_read_byte(RF_R_RX_PAYLOAD);
  while ( data_len-- )
    *current++ = _rf24_spi_send_read_byte(0xff);
  while ( blank_len-- )
    _rf24_spi_send_read_byte(0xff);
  _rf24_csn(HIGH);

  return status;
}

uint8_t _rf24_flush_rx(void)
{
  uint8_t status;

  _rf24_csn(LOW);
  status = _rf24_spi_send_read_byte(RF_FLUSH_RX);
  _rf24_csn(HIGH);

  return status;
}

uint8_t _rf24_flush_tx(void)
{
  uint8_t status;

  _rf24_csn(LOW);
  status = _rf24_spi_send_read_byte(RF_FLUSH_TX);
  _rf24_csn(HIGH);

  return status;
}

uint8_t _rf24_get_status(void)
{
  uint8_t status;

  _rf24_csn(LOW);
  status = _rf24_spi_send_read_byte(RF_NOP);
  _rf24_csn(HIGH);

  return status;
}

void _rf24_print_status(uint8_t status)
{
  printf("STATUS\t\t = 0x%02x RX_DR=%x TX_DS=%x MAX_RT=%x RX_P_NO=%x TX_FULL=%x\r\n",
    status,
    (status & RF_STATUS_RX_DR) ? 1 : 0,
    (status & RF_STATUS_TX_DS) ? 1 : 0,
    (status & RF_STATUS_MAX_RT) ? 1 : 0,
    (status & RF_STATUS_RX_P_NO) >> 1,
    (status & RF_STATUS_TX_FULL) ? 1 : 0
  );
}

void _rf24_print_observe_tx(uint8_t value)
{
  printf("OBSERVE_TX=%02x: POLS_CNT=%x ARC_CNT=%x\r\n",
    value,
    (value & RF_OBSERVE_TX_PLOS_CNT) >> 4,
    value & RF_OBSERVE_TX_ARC_CNT
  );
}

void _rf24_print_byte_register(const char* name, uint8_t reg, uint8_t qty)
{
  char extra_tab = strlen(name) < 8 ? '\t' : 0;
  printf("%s""\t%c =", name, extra_tab);
  while (qty--)
    printf(" 0x%02x", _rf24_read_register_1_byte(reg++));
  printf("\r\n");
}

void _rf24_print_address_register(const char* name, uint8_t reg, uint8_t qty)
{
  char extra_tab = strlen(name) < 8 ? '\t' : 0;
  printf("%s""\t%c =", name, extra_tab);

  while (qty--)
  {
    uint8_t buffer[5];
    uint8_t* bufptr;
    _rf24_read_register(reg++,buffer,sizeof buffer);

    printf(" 0x");
    bufptr = buffer + sizeof buffer;
    while( --bufptr >= buffer )
      printf("%02x", *bufptr);
  }

  printf("\r\n");
}

void rf24_default(void)
{
  _rf24_wide_band = true;
  _rf24_payload_size = 32;
  _rf24_ack_payload_available = false;
  _rf24_dynamic_payloads_enabled = false;
  _rf24_pipe0_reading_address_exists = false;
  memset(_rf24_pipe0_reading_address, 0, sizeof _rf24_pipe0_reading_address);
}

void rf24_setChannel(uint8_t channel)
{
  // TODO: This method could take advantage of the 'wide_band' calculation
  // done in setChannel() to require certain channel spacing.

  const uint8_t max_channel = 127;
  _rf24_write_register_1_byte(RF_RF_CH, channel < max_channel ? channel : max_channel);
}

void rf24_setPayloadSize(uint8_t size)
{
  const uint8_t max_payload_size = 32;
  _rf24_payload_size = size < max_payload_size ? size : max_payload_size;
}

uint8_t rf24_getPayloadSize(void)
{
  return _rf24_payload_size;
}

void rf24_printDetails(void)
{
  _rf24_print_status(_rf24_get_status());

  _rf24_print_address_register("RX_ADDR_P0-1", RF_RX_ADDR_P0, 2);
  _rf24_print_byte_register("RX_ADDR_P2-5", RF_RX_ADDR_P2, 4);
  _rf24_print_address_register("TX_ADDR", RF_TX_ADDR, 1);

  _rf24_print_byte_register("RX_PW_P0-6", RF_RX_PW_P0, 6);
  _rf24_print_byte_register("EN_AA", RF_EN_AA, 1);
  _rf24_print_byte_register("EN_RXADDR", RF_EN_RXADDR, 1);
  _rf24_print_byte_register("RF_CH", RF_RF_CH, 1);
  _rf24_print_byte_register("RF_SETUP", RF_RF_SETUP, 1);
  _rf24_print_byte_register("CONFIG", RF_CONFIG, 1);
  _rf24_print_byte_register("DYNPD/FEATURE", RF_DYNPD, 2);

  printf("Data Rate\t = %s\r\n", _rf24_datarate_e_str_P[rf24_getDataRate()]);
  printf("Model\t\t = %s\r\n", _rf24_model_e_str_P[0]);
  printf("CRC Length\t = %s\r\n", _rf24_crclength_e_str_P[rf24_getCRCLength()]);
  printf("PA Power\t = %s\r\n", _rf24_pa_dbm_e_str_P[rf24_getPALevel()]);
}

void rf24_begin(void)
{
  // Initialize SPI bus
  rf_spi_configure_enable();

  _rf24_ce(LOW);
  _rf24_csn(HIGH);

  // Must allow the radio time to settle else configuration bits will not necessarily stick.
  // This is actually only required following power up but some settling time also appears to
  // be required after resets too. For full coverage, we'll always assume the worst.
  // Enabling 16b CRC is by far the most obvious case if the wrong timing is used - or skipped.
  // Technically we require 4.5ms + 14us as a worst case. We'll just call it 5ms for good measure.
  // WARNING: Delay is based on P-variant whereby non-P *may* require different timing.
  delay_ms(5) ;

  // Set 1500uS (minimum for 32B payload in ESB@250KBPS) timeouts, to make testing a little easier
  // WARNING: If this is ever lowered, either 250KBS mode with AA is broken or maximum packet
  // sizes must never be used. See documentation for a more complete explanation.
  _rf24_write_register_1_byte(RF_SETUP_RETR, RF_SETUP_RETR_ARD_1250 | RF_SETUP_RETR_ARC_15);

  // Restore our default PA level
  rf24_setPALevel(RF24_PA_MAX);

  // Then set the data rate to the slowest (and most reliable) speed supported by all
  // hardware.
  rf24_setDataRate(RF24_1MBPS);

  // Initialize CRC and request 2-byte (16bit) CRC
  rf24_setCRCLength(RF24_CRC_16);
  
  // Disable dynamic payloads, to match dynamic_payloads_enabled setting
  _rf24_write_register_1_byte(RF_DYNPD, 0);

  // Reset current status
  // Notice reset and flush is the last thing we do
  _rf24_write_register_1_byte(RF_STATUS, RF_STATUS_RX_DR | RF_STATUS_TX_DS | RF_STATUS_MAX_RT);

  // Set up default configuration.  Callers can always change it later.
  // This channel should be universally safe and not bleed over into adjacent
  // spectrum.
  rf24_setChannel(76);

  // Flush buffers
  _rf24_flush_rx();
  _rf24_flush_tx();
}

void rf24_startListening(void)
{
  _rf24_write_register_1_byte(RF_CONFIG, _rf24_read_register_1_byte(RF_CONFIG) | RF_CONFIG_PWR_UP | RF_CONFIG_PRIM_RX);
  _rf24_write_register_1_byte(RF_STATUS, RF_STATUS_RX_DR | RF_STATUS_TX_DS | RF_STATUS_MAX_RT);

  // Restore the pipe0 adddress, if exists
  if (_rf24_pipe0_reading_address_exists)
    _rf24_write_register(RF_RX_ADDR_P0, (const uint8_t*) (&_rf24_pipe0_reading_address[0]), 5);

  // Flush buffers
  _rf24_flush_rx();
  _rf24_flush_tx();

  // Go!
  _rf24_ce(HIGH);

  // wait for the radio to come up (130us actually only needed)
  delay_us(130);
}

void rf24_stopListening(void)
{
  _rf24_ce(LOW);
  _rf24_flush_tx();
  _rf24_flush_rx();
}

void rf24_powerDown(void)
{
  _rf24_write_register_1_byte(RF_CONFIG, _rf24_read_register_1_byte(RF_CONFIG) & ~RF_CONFIG_PWR_UP);
}

void rf24_powerUp(void)
{
  _rf24_write_register_1_byte(RF_CONFIG, _rf24_read_register_1_byte(RF_CONFIG) | RF_CONFIG_PWR_UP);
}

bool rf24_write(const void* buf, uint8_t len)
{
  uint8_t observe_tx;
  uint8_t status;
  bool tx_ok, tx_fail;
  uint32_t sent_at;
  bool result;
  const uint32_t timeout = 500; //ms to wait for timeout
  
  result = false;

  // Begin the write
  rf24_startWrite(buf, len);

  // ------------
  // At this point we could return from a non-blocking write, and then call
  // the rest after an interrupt

  // Instead, we are going to block here until we get TX_DS (transmission completed and ack'd)
  // or MAX_RT (maximum retries, transmission failed).  Also, we'll timeout in case the radio
  // is flaky and we get neither.

  // IN the end, the send should be blocking.  It comes back in 60ms worst case, or much faster
  // if I tighted up the retry logic.  (Default settings will be 1500us.
  // Monitor the send
  sent_at = millis();
  
  do
  {
    status = _rf24_read_register(RF_OBSERVE_TX, &observe_tx,1);
  }
  while(!(status & (RF_STATUS_TX_DS | RF_STATUS_MAX_RT)) && (millis() - sent_at < timeout));

  // The part above is what you could recreate with your own interrupt handler,
  // and then call this when you got an interrupt
  // ------------

  // Call this when you get an interrupt
  // The status tells us three things
  // * The send was successful (TX_DS)
  // * The send failed, too many retries (MAX_RT)
  // * There is an ack packet waiting (RX_DR)
  rf24_whatHappened(&tx_ok, &tx_fail, &_rf24_ack_payload_available);
  
  result = tx_ok;

  // Handle the ack packet
  if (_rf24_ack_payload_available)
  {
    _rf24_ack_payload_length = rf24_getDynamicPayloadSize();
  }

  // Yay, we are done.

  // Power down
  rf24_powerDown();

  // Flush buffers (Is this a relic of past experimentation, and not needed anymore??)
  _rf24_flush_tx();

  return result;
}

void rf24_startWrite(const void* buf, uint8_t len)
{
  // Transmitter power-up
  _rf24_write_register_1_byte(RF_CONFIG, (_rf24_read_register_1_byte(RF_CONFIG) | RF_CONFIG_PWR_UP) & ~RF_CONFIG_PRIM_RX);
  delay_us(150);

  // Send the payload
  _rf24_write_payload(buf, len);

  // Allons!
  _rf24_ce(HIGH);
  delay_us(15);
  _rf24_ce(LOW);
}

uint8_t rf24_getDynamicPayloadSize(void)
{
  uint8_t status;

  _rf24_csn(LOW);
  _rf24_spi_send_read_byte(RF_R_RX_PL_WID);
  status = _rf24_spi_send_read_byte(0xff);
  _rf24_csn(HIGH);

  return status;
}

bool rf24_available(void)
{
  return rf24_availablePipe(NULL);
}

bool rf24_availablePipe(uint8_t* pipe_num)
{
  uint8_t status;
  bool result;

  status = _rf24_get_status();

  // Too noisy, enable if you really want lots o data!!
  //IF_SERIAL_DEBUG(print_status(status));

  result = (status & RF_STATUS_RX_DR);

  if (result)
  {
    // If the caller wants the pipe number, include that
    if (pipe_num)
      *pipe_num = (status & RF_STATUS_RX_P_NO) >> 1;

    // Clear the status bit

    // ??? Should this REALLY be cleared now?  Or wait until we
    // actually READ the payload?

    _rf24_write_register_1_byte(RF_STATUS, RF_STATUS_RX_DR);

    // Handle ack payload receipt
    if (status & RF_STATUS_TX_DS)
    {
      _rf24_write_register_1_byte(RF_STATUS, RF_STATUS_TX_DS);
    }
  }

  return result;
}

bool rf24_read(void* buf, uint8_t len)
{
  // Fetch the payload
  _rf24_read_payload(buf, len);

  // was this the last of the data available?
  return _rf24_read_register_1_byte(RF_FIFO_STATUS) & RF_FIFO_STATUS_RX_EMPTY;
}

void rf24_whatHappened(bool* tx_ok, bool* tx_fail, bool* rx_ready)
{
  // Read the status & reset the status in one easy call
  // Or is that such a good idea?
  uint8_t status = _rf24_write_register_1_byte(RF_STATUS, RF_STATUS_RX_DR | RF_STATUS_TX_DS | RF_STATUS_MAX_RT);

  // Report to the user what happened
  *tx_ok = status & RF_STATUS_TX_DS;
  *tx_fail = status & RF_STATUS_MAX_RT;
  *rx_ready = status & RF_STATUS_RX_DR;
}

void rf24_openWritingPipe(uint8_t* value)
{
  const uint8_t max_payload_size = 32;

  _rf24_write_register(RF_RX_ADDR_P0, value, 5);
  _rf24_write_register(RF_TX_ADDR, value, 5);
  _rf24_write_register_1_byte(RF_RX_PW_P0, _rf24_payload_size < max_payload_size ? _rf24_payload_size : max_payload_size);
}

void rf24_openReadingPipe(uint8_t child, uint8_t* address)
{
  // If this is pipe 0, cache the address.  This is needed because
  // openWritingPipe() will overwrite the pipe 0 address, so
  // startListening() will have to restore it.
  if (child == 0) {
    memcpy(address, &_rf24_pipe0_reading_address[0], sizeof _rf24_pipe0_reading_address);
    _rf24_pipe0_reading_address_exists = true;
  }

  if (child <= 6)
  {
    // For pipes 2-5, only write the LSB
    if ( child < 2 )
      _rf24_write_register(_rf24_child_pipe[child], (const uint8_t*) address, 5);
    else
      _rf24_write_register(_rf24_child_pipe[child], (const uint8_t*) address, 1);

    _rf24_write_register_1_byte(_rf24_child_payload_size[child], _rf24_payload_size);

    // Note it would be more efficient to set all of the bits for all open
    // pipes at once.  However, I thought it would make the calling code
    // more simple to do it this way.
    _rf24_write_register_1_byte(RF_EN_RXADDR, _rf24_read_register_1_byte(RF_EN_RXADDR) | _rf24_child_pipe_enable[child]);
  }
}

void _rf24_toggle_features(void)
{
  _rf24_csn(LOW);
  _rf24_spi_send_read_byte(RF24_ACTIVATE);
  _rf24_spi_send_read_byte(0x73);
  _rf24_csn(HIGH);
}

void rf24_enableDynamicPayloads(void)
{
  // Enable dynamic payload throughout the system
  _rf24_write_register_1_byte(RF_FEATURE, _rf24_read_register_1_byte(RF_FEATURE) | RF_FEATURE_EN_DPL);

  // If it didn't work, the features are not enabled
  if (!_rf24_read_register_1_byte(RF_FEATURE))
  {
    // So enable them and try again
    _rf24_toggle_features();
    _rf24_write_register_1_byte(RF_FEATURE, _rf24_read_register_1_byte(RF_FEATURE) | RF_FEATURE_EN_DPL);
  }

  // Enable dynamic payload on all pipes
  //
  // Not sure the use case of only having dynamic payload on certain
  // pipes, so the library does not support it.

  _rf24_write_register_1_byte(RF_DYNPD, _rf24_read_register_1_byte(RF_DYNPD) | RF_DYNPD_DPL_P5 | RF_DYNPD_DPL_P4 | RF_DYNPD_DPL_P3 | RF_DYNPD_DPL_P2 | RF_DYNPD_DPL_P1 | RF_DYNPD_DPL_P0);

  _rf24_dynamic_payloads_enabled = true;
}

void rf24_enableAckPayload(void)
{
  //
  // enable ack payload and dynamic payload features
  //

  _rf24_write_register_1_byte(RF_FEATURE, _rf24_read_register_1_byte(RF_FEATURE) | RF_FEATURE_EN_ACK_PAY | RF_FEATURE_EN_DPL);

  // If it didn't work, the features are not enabled
  if (!_rf24_read_register_1_byte(RF_FEATURE))
  {
    // So enable them and try again
    _rf24_toggle_features();
    _rf24_write_register_1_byte(RF_FEATURE, _rf24_read_register_1_byte(RF_FEATURE) | RF_FEATURE_EN_ACK_PAY | RF_FEATURE_EN_DPL);
  }

  //
  // Enable dynamic payload on pipes 0 & 1
  //

  _rf24_write_register_1_byte(RF_DYNPD, _rf24_read_register_1_byte(RF_DYNPD) | RF_DYNPD_DPL_P1 | RF_DYNPD_DPL_P0);
}

void rf24_writeAckPayload(uint8_t pipe, const void* buf, uint8_t len)
{
  const uint8_t max_payload_size = 32;
  const uint8_t* current = (const uint8_t*) buf;
  uint8_t data_len;

  _rf24_csn(LOW);
  _rf24_spi_send_read_byte(RF24_W_ACK_PAYLOAD | (pipe & 0x7));
  data_len = len < max_payload_size ? len : max_payload_size;
  while ( data_len-- )
    _rf24_spi_send_read_byte(*current++);

  _rf24_csn(HIGH);
}

bool rf24_isAckPayloadAvailable(void)
{
  bool result = _rf24_ack_payload_available;
  _rf24_ack_payload_available = false;
  return result;
}

void rf24_setAutoAck(bool enable)
{
  if (enable)
    _rf24_write_register_1_byte(RF_EN_AA, 0x3f);
  else
    _rf24_write_register_1_byte(RF_EN_AA, 0);
}

void rf24_setAutoAckPipe(uint8_t pipe, bool enable)
{
  uint8_t en_aa;
  if ( pipe <= 6 )
  {
    en_aa = _rf24_read_register_1_byte(RF_EN_AA);
    if(enable)
    {
      en_aa |= 1 << pipe;
    }
    else
    {
      en_aa &= ~(1 << pipe);
    }
    _rf24_write_register_1_byte(RF_EN_AA, en_aa);
  }
}

bool rf24_testRPD(void)
{
  return (_rf24_read_register_1_byte(RF_RPD) & 1);
}

void rf24_setPALevel(rf24_pa_dbm_e level)
{
  uint8_t setup = _rf24_read_register_1_byte(RF_RF_SETUP);
  setup &= ~(RF24_RF_PWR_LOW | RF24_RF_PWR_HIGH) ;

  // switch uses RAM (evil!)
  if ( level == RF24_PA_MAX )
  {
    setup |= (RF24_RF_PWR_LOW | RF24_RF_PWR_HIGH);
  }
  else if (level == RF24_PA_HIGH)
  {
    setup |= RF24_RF_PWR_HIGH;
  }
  else if (level == RF24_PA_LOW)
  {
    setup |= RF24_RF_PWR_LOW;
  }
  else if (level == RF24_PA_MIN)
  {
    // nothing
  }
  else if (level == RF24_PA_ERROR)
  {
    // On error, go to maximum PA
    setup |= (RF24_RF_PWR_LOW | RF24_RF_PWR_HIGH);
  }

  _rf24_write_register_1_byte(RF_RF_SETUP, setup);
}

rf24_pa_dbm_e rf24_getPALevel(void)
{
  rf24_pa_dbm_e result;
  uint8_t power;

  result = RF24_PA_ERROR;
  power = _rf24_read_register_1_byte(RF_RF_SETUP) & (RF24_RF_PWR_LOW | RF24_RF_PWR_HIGH);

  // switch uses RAM (evil!)
  if (power == (RF24_RF_PWR_LOW | RF24_RF_PWR_HIGH))
  {
    result = RF24_PA_MAX;
  }
  else if (power == RF24_RF_PWR_HIGH)
  {
    result = RF24_PA_HIGH;
  }
  else if (power == RF24_RF_PWR_LOW)
  {
    result = RF24_PA_LOW;
  }
  else
  {
    result = RF24_PA_MIN;
  }

  return result;
}

bool rf24_setDataRate(rf24_datarate_e speed)
{
  bool result;
  uint8_t setup;
  
  result = false;
  setup = _rf24_read_register_1_byte(RF_RF_SETUP);

  // HIGH and LOW '00' is 1Mbs - our default
  _rf24_wide_band = false ;
  setup &= ~(RF_RF_SETUP_RF_DR_LOW | RF_RF_SETUP_RF_DR_HIGH);
  if (speed == RF24_250KBPS)
  {
    // Must set the RF_DR_LOW to 1; RF_DR_HIGH (used to be RF_DR) is already 0
    // Making it '10'.
    _rf24_wide_band = false ;
    setup |= RF_RF_SETUP_RF_DR_LOW;
  }
  else
  {
    // Set 2Mbs, RF_DR (RF_DR_HIGH) is set 1
    // Making it '01'
    if (speed == RF24_2MBPS)
    {
      _rf24_wide_band = true;
      setup |= RF_RF_SETUP_RF_DR_HIGH;
    }
    else
    {
      // 1Mbs
      _rf24_wide_band = false ;
    }
  }
  _rf24_write_register_1_byte(RF_RF_SETUP, setup);

  // Verify our result
  if (_rf24_read_register_1_byte(RF_RF_SETUP) == setup)
  {
    result = true;
  }
  else
  {
    _rf24_wide_band = false;
  }

  return result;
}

rf24_datarate_e rf24_getDataRate(void)
{
  rf24_datarate_e result;
  uint8_t dr;
  
  dr = _rf24_read_register_1_byte(RF_RF_SETUP) & (RF_RF_SETUP_RF_DR_LOW | RF_RF_SETUP_RF_DR_HIGH);

  // switch uses RAM (evil!)
  // Order matters in our case below
  if (dr == RF_RF_SETUP_RF_DR_LOW)
  {
    // '10' = 250KBPS
    result = RF24_250KBPS;
  }
  else if (dr == RF_RF_SETUP_RF_DR_HIGH)
  {
    // '01' = 2MBPS
    result = RF24_2MBPS;
  }
  else
  {
    // '00' = 1MBPS
    result = RF24_1MBPS;
  }
  return result;
}

void rf24_setCRCLength(rf24_crclength_e length)
{
  uint8_t config;
  
  config = _rf24_read_register_1_byte(RF_CONFIG) & ~(RF_CONFIG_CRCO | RF_CONFIG_EN_CRC);
  
  // switch uses RAM (evil!)
  if ( length == RF24_CRC_DISABLED )
  {
    // Do nothing, we turned it off above. 
  }
  else if ( length == RF24_CRC_8 )
  {
    config |= RF_CONFIG_EN_CRC;
  }
  else
  {
    config |= RF_CONFIG_EN_CRC;
    config |= RF_CONFIG_CRCO;
  }
  _rf24_write_register_1_byte(RF_CONFIG, config);
}

rf24_crclength_e rf24_getCRCLength(void)
{
  rf24_crclength_e result;
  uint8_t config;

  result = RF24_CRC_DISABLED;
  config = _rf24_read_register_1_byte(RF_CONFIG) & (RF_CONFIG_CRCO | RF_CONFIG_EN_CRC);

  if (config & RF_CONFIG_EN_CRC)
  {
    if (config & RF_CONFIG_CRCO)
      result = RF24_CRC_16;
    else
      result = RF24_CRC_8;
  }

  return result;
}

void rf24_disableCRC(void)
{
  uint8_t disable;
  disable = _rf24_read_register_1_byte(RF_CONFIG) & ~(RF_CONFIG_EN_CRC);
  _rf24_write_register_1_byte(RF_CONFIG, disable);
}

void rf24_setRetries(uint8_t delay, uint8_t count)
{
  _rf24_write_register_1_byte(RF_SETUP_RETR, (delay & 0xf) << 4 | (count & 0xf));
}